# frozen_string_literal: true

class Detector
  # Detector::Citation attempts to identify citations based on the prevalence of individual sub-patterns. It is not
  # targeted at a particular citation format, but was designed based on characteristics of five formats: APA, MLA,
  # Chicago, Terabian, and IEEE.
  #
  # It receives a phrase (often from `Term.phrase`), which is parsed in various ways en route to calculating a final
  # score. Phrases with a higher score are more citation-like, while a score of 0 indicates a phrase that has no
  # hallmarks of being a citation.
  # Phrases whose score is higher than the REQUIRED_SCORE value can be registered as a Detection.
  class Citation
    attr_reader :features, :score, :subpatterns, :summary

    # shared singleton methods
    extend Detector::BulkChecker

    # Citation patterns are regular expressions which attempt to identify structures that are part of many citations.
    # This object is used as part of the pattern_checker method. Some of these patterns may get promoted to the Detector
    # model if they prove useful beyond a Citation context.
    CITATION_PATTERNS = {
      apa_volume_issue: /\d+\(\d+\)/,
      no: /no\.\s\d+/,
      pages: /\d+-+\d+/,
      pp: /pp\.\s\d+/,
      vol: /vol\.\s\d+/,
      year_parens: /\(\d{4}\)/,
      brackets: /\[.*?\]/,
      lastnames: /[A-Z][a-z]+[.,]/,
      quotes: /&quot;.*?&quot;/
    }.freeze

    # The required score value is the threshold needed for a phrase to be officially recorded with a Detection via it's
    # associated Term.
    # Hint: set this to 0 in development environments if you want to temporarily see all output
    # of `.check_all_matches` rather than just the matches that met this threshold.
    REQUIRED_SCORE = 6

    # Summary thresholds are used by the calculate_score method. This class counts the number of occurrences of specific
    # characters in the @summary instance variable. The thresholds here determine whether any of those counts are high
    # enough to contribute to the phrase's citation score.
    SUMMARY_THRESHOLDS = {
      characters: 25,
      colons: 2,
      commas: 2,
      periods: 2,
      semicolons: 2,
      words: 5
    }.freeze

    # Detection? is a convenience method to check whether the calculated @score is high enough to qualify as a citation.
    #
    # @return boolean
    def detection?
      @score >= REQUIRED_SCORE
    end

    # The initializer handles the parsing of a phrase, and subsequent population of the @subpatterns, @summary,
    # and @score instance variables. @subpatterns contains all the citation components which have been flagged by the
    # CITATION_PATTERNS hash. @summary contains counts of how often certain characters or words appear in the phrase.
    # Finally, the @score value is a summary of how many elements in the subpatterns or summary report were detected.
    #
    # @note This method can be called directly via Detector::Citation.new(phrase). It is also called indirectly via the
    #       Detector::Citation.record(Term) instance method. This method can be called directly when a Detection is not
    #       desired.
    # @param phrase String. Often a `Term.phrase`.
    # @return Nothing intentional. Data is written to Hashes `@subpatterns`, `@summary`,
    #   and `@score` during processing.
    def initialize(phrase)
      @features = {}
      @subpatterns = {}
      @summary = {}
      pattern_checker(phrase)
      summarize(phrase)
      extract_features
      @subpatterns.delete_if { |_, v| v == [] }
      @score = calculate_score
    end

    def detections
      return unless detection?

      [@summary, @subpatterns, @score]
    end

    # The record method first runs all of the parsers by running the initialize method. If the resulting score is higher
    # than the REQUIRED_SCORE value, then a Detection is registered.
    #
    # @param term [Term]
    #
    # @return [Hash] a hash of features extracted from the Term
    def self.record(term)
      cit = Detector::Citation.new(term.phrase)

      if cit.detection?
        Detection.find_or_create_by(
          term:,
          detector: Detector.where(name: 'Citation').first,
          detector_version: ENV.fetch('DETECTOR_VERSION', 'unset')
        )
      end

      cit.features
    end

    private

    # This combines the two reports generated by the Citation detector (subpatterns and summary), and calculates the
    # final score value from their contents.
    #
    # Any detected subpattern is counted toward the score (multiple detections do not get counted twice). For example,
    # if the brackets pattern finds two matches, it still only adds one to the final score.
    #
    # For the summary report, each value is compared with a threshold value in the SUMMARY_THRESHOLDS constant. The
    # number of values which meet or exceed their threshold are added to the score. As an example, if a search phrase has
    # five words, this value is compared to the word threshold (also five). Because the threshold is met, the score gets
    # incremented by one.
    #
    # @return integer
    def calculate_score
      summary_score = @summary.count do |key, value|
        SUMMARY_THRESHOLDS.key?(key) && value >= SUMMARY_THRESHOLDS[key]
      end

      summary_score + @subpatterns.length
    end

    # This calculates the number of characters in the search phrase. It is called by the summarize method.
    def characters(phrase)
      phrase.length
    end

    # This counts the number of colons that appear in the search phrase, because they tend to appear more often in
    # citations than in other searches. It is called by the summarize method.
    def colons(phrase)
      phrase.count(':')
    end

    # This counts the number of commas in the search phrase. It is called by the summarize method.
    def commas(phrase)
      phrase.count(',')
    end

    # This converts the already-built @subpatterns and @summary instance variables into the @features instance variable,
    # which has a format suitable for sending to our prediction algorithm.
    def extract_features
      # Need to create a separate instance variable, so use .deep_dup
      @features = @subpatterns.deep_dup
      # Convert the @subpattern structure of {no: = [], pages: ['194-204']} (a hash of matched substrings, with some
      # empty) into {no: 0, pages: 1} (a hash of integers, some zero)
      @features = @features.transform_values(&:length)
      # Now join the re-shaped hash with the @summary variable, so everything is in one place.
      @features = @features.merge(summary)
    end

    # This builds one of the two main components of the Citation detector - the subpattern report. It uses each of the
    # regular expressions in the CITATION_PATTERNS constant, extracting all matches using the scan method.
    #
    # @return hash
    def pattern_checker(phrase)
      CITATION_PATTERNS.each_pair do |type, pattern|
        @subpatterns[type.to_sym] = scan(pattern, phrase)
      end
    end

    # This counts the number of periods in the search phrase. It is called by the summarize method.
    def periods(phrase)
      phrase.count('.')
    end

    # This is a convenience method for the scan method, which is used by pattern_checker.
    def scan(pattern, phrase)
      phrase.scan(pattern).map(&:strip)
    end

    # This counts the semicolons in the search phrase. It is called by the summarize method.
    def semicolons(phrase)
      phrase.count(';')
    end

    # This builds one of the two main components of the Citation detector - the summary report. It calls each of the
    # methods in the first line - which all return integers - and puts the result as a key-value pair in the @summary
    # instance variable.
    #
    # @return hash
    def summarize(phrase)
      %w[characters colons commas periods semicolons words].each do |check|
        @summary[check.to_sym] = send(check, phrase)
      end
    end

    # This counts the number of words in the search phrase. It is called by the summarize method.
    def words(phrase)
      phrase.split.length
    end
  end
end
